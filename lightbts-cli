#!/usr/bin/python

from __future__ import print_function

import os
import argparse
import sys
import subprocess
import tempfile
import email.message

import lightbts

def is_interactive():
    return os.isatty(0) and os.isatty(1)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def do_init(args):
    if not args.dir:
        args.dir = args.data

    if not args.dir:
        args.dir = os.path.join(os.getcwd(), ".lightbts")

    new = not os.access(os.path.join(args.dir, "config"), os.F_OK)

    lightbts.init(args.dir)

    if new:
        eprint("Initialized empty LightBTS instance in " + args.dir)
    else:
        eprint("Reinitialized existing LightBTS instance in " + args.dir)

def do_config(args):
    option = args.option.split('.')
    if len(option) != 2:
        eprint("Invalid option name")
        exit(1)

    (section, option) = option

    if not args.value:
        try:
            print(lightbts.config.get(section, option))
        except:
            exit(1)
    else:
        if not lightbts.config.has_section(section):
            lightbts.config.add_section(section)
        lightbts.config.set(section, option, args.value)

def do_list(args):
    for bug in lightbts.list_bugs(args):
        print("{:>6} {:6} {:9}  {:}".format(bug.id, bug.statusname, bug.severityname, bug.title))

def do_show_bug(bugno, verbose):
    bug = lightbts.get_bug(bugno)
    if not bug:
        eprint('Could not find bug #' + str(bugno))
        exit(1)

    found_versions = bug.get_found_versions()
    fixed_versions = bug.get_fixed_versions()
    print('Bug#' + str(bug.id) + ': ' + bug.title)
    print('Status: ' + bug.statusname)
    if bug.submitter:
        print('Submitted by:  ' + bug.submitter)
    if bug.owner != bug.submitter:
        print('Owner by: ' + bug.owner)
    if bug.status and bug.progress:
        print('Progress: ' + str(bug.progress) + '%')
    if found_versions:
        print('Found in: ' + ' '.join(found_versions))
    if fixed_versions:
        print('Fixed in: ' + ' '.join(fixed_versions))
    print('Severity: ' + bug.severityname)
    tags = bug.get_tags()
    if tags:
        print('Tags: ' + ' '.join(tags))
    if bug.deadline:
        print('Deadline: ' + email.utils.formatdate(float(bug.deadline)))
    if bug.milestone:
        print('Milestone: ' + bug.milestone)

    print('')

    for msg in bug.get_messages():
        if(verbose):
            print('From: ' + msg.msg['From'])
            print('To: ' + msg.msg['To'])
            print('Subject: ' + msg.msg['Subject'])
            print('Date: ' + msg.msg['Date'])
            print('Message-ID: ' + msg.msg['Message-ID'])
            print('')
            print(msg.msg.get_payload());
            print('')
        else:
            print(msg.msgid)

def do_show_message(msgid):
    msg = lightbts.get_message(msgid)
    if not msg:
        eprint('Could not find message with id ' + msgid)
        exit(1)

    bug = lightbts.get_bug(msg.bug)
    found_versions = bug.get_found_versions()
    fixed_versions = bug.get_fixed_versions()
    print('Bug#' + str(bug.id) + ': ' + bug.title)
    print('Status: ' + bug.statusname)
    if found_versions:
        print('Found in: ' + ' '.join(found_versions))
    if fixed_versions:
        print('Fixed in: ' + ' '.join(fixed_versions))
    print('Severity: ' + bug.severityname)
    tags = bug.get_tags()
    if tags:
        print('Tags: ' + tags)
    print('')
    print(msg.msg.as_string());

def do_show(args):
    if '@' in args.id:
        return do_show_message(args.id)
    else:
        return do_show_bug(int(args.id), args.verbose)

def do_search(args):
    for bug in lightbts.search_bugs(args):
        print("{:>6} {:6} {:9}  {:}".format(bug.id, bug.statusname, bug.severityname, bug.title))

def edit_interactive(msg, hint = 'bug'):
    # Find out which editor to use
    editor = lightbts.config.get("cli", "editor")
    if not editor:
        editor = os.getenv("VISUAL")
    if not editor:
        editor = os.getenv("EDITOR")
    if not editor:
        editor = "edit"

    # Create a temporary file, use .eml suffix (vim can use it for syntax highlighting)
    (fd, path) = tempfile.mkstemp(prefix="lightbts-" + hint + "-", suffix='.eml', text=True)
    file = os.fdopen(fd, "w+")

    #Write message
    text = msg.as_string()
    file.write(text)

    file.seek(0)
    stat_before = os.fstat(fd)

    start = ''

    # Call the editor
    retval = subprocess.call([editor, '+' + str(start), path])

    if retval != 0:
        eprint('"' + editor + '" returned with a non-zero exit code')
        file.close()
        os.unlink(path)
        return None

    # Read back the edited message, if it was changed at all
    stat_after = os.fstat(fd)
    if stat_before.st_mtime == stat_after.st_mtime and stat_before.st_size == stat_after.st_size:
        result = None
    else:
        result = email.message_from_file(file);

    file.close()
    os.unlink(path)

    return result

def do_create(args):
    # Create message headers, start with From: so the file command recognizes it as message/rfc822
    msg = email.message.Message()
    msg['From'] = lightbts.get_local_email_address()
    msg['Subject'] = ' '.join(args.title)

    if args.version:
        msg['Version'] = args.version
    if args.severity:
        msg['Severity'] = args.severity
    if args.tag:
        msg['Tags'] = args.tag

    if is_interactive():
        msg = edit_interactive(msg, 'create')
        if not msg:
            eprint("Aborting new bug report.")
            exit(1)
    else:
        msg.set_payload(sys.stdin.read())

    msg['To'] = 'LightBTS'
    msg['Date'] = email.utils.formatdate()
    msg['User-Agent'] = 'LightBTS/' + lightbts.__version__

    (bug, new) = lightbts.import_email(msg)

    if not bug:
        exit(1)

    action = ''
    if msg['Version']:
        bug.found(msg['Version'])
    if msg['Tags']: #TODO: handle multiple tags
        bug.add_tag(msg['Tags'])
    if msg['Severity']:
        bug.set_severity(msg['Severity'])
    eprint('Thank you for reporting a bug, which has been assigned number ' + str(bug.id))

def quote(text):
    return ''.join('> ' + line + '\n' for line in text.strip('\n').split('\n'))

def do_reply(args):
    if args.close and args.reopen:
        eprint('Make up your mind!')
        exit(1)

    if '@' in args.id:
        origmsg = lightbts.get_message(args.id)
        if not msg:
            eprint('Could not find message ID ' + args.id)
            exit(1)
        bug = lightbts.get_bug(msg.get_bug())
    else:
        bug = lightbts.get_bug(int(args.id))
        if not bug:
            eprint('Could not find bug #' + args.id)
            exit(1)
        origmsg = lightbts.get_message(bug.get_first_msgid())

    # Create message headers, start with From: so the file command recognizes it as message/rfc822
    msg = email.message.Message()
    msg['From'] = lightbts.get_local_email_address()
    msg['Subject'] = bug.title

    if is_interactive():
        origdate = origmsg.get_msg()['Date']
        (origrealname, origaddress) = email.utils.parseaddr(origmsg.get_msg()['From'])
        body = "On " + origdate + ", " + origrealname + " wrote:\n\n"
        body += quote(origmsg.get_body())

        msg.set_payload(body)

        msg = edit_interactive(msg, 'reply-' + str(bug.get_id()))
        if not msg:
            eprint("Aborting bug reply.")
            exit(1)
    else:
        msg.set_payload(sys.stdin.read())

    msg['To'] = 'LightBTS'
    msg['Date'] = email.utils.formatdate()
    msg['User-Agent'] = 'LightBTS/' + lightbts.__version__
    msg['In-Reply-To'] = '<' + origmsg.get_msgid() + '>'

    (bug, new) = lightbts.import_email(msg);

    action = ''
    if args.version:
        if args.close:
            bug.fixed(args.version)
            action += 'fixed ' + args.version + '\n'
        else:
            bug.found(args.version)
            action += 'found ' + args.version + '\n'
    if args.tag:
        bug.add_tag(args.tag)
        action += 'tags +' + args.tag + '\n'
    if args.close:
        bug.close()
        action += 'close\n'
    if args.reopen:
        bug.reopen()
        action += 'reopen\n'
    if action:
        bug.record_action(action)
    eprint('Thank you for reporting additional information for bug number ' + str(bug.id))


def do_close(args):
    bug = lightbts.get_bug(args.id)
    action = 'close'
    bug.close()

    if args.version:
        bug.fixed(args.version)
        action += '\nfixed ' + args.version

    if args.tag:
        bug.add_tag(args.tag)
        action += '\ntags +' + args.tag

    bug.record_action(action)

def do_reopen(args):
    bug = lightbts.get_bug(args.id)
    bug.reopen()
    action = 'reopen'

    if args.version:
        bug.found(args.version)
        action += '\nfound ' + args.version
    if args.tag:
        bug.add_tag(args.tag)
        action += '\ntags +' + args.tag

    bug.record_action(action)

def do_retitle(args):
    bug = lightbts.get_bug(args.id)
    title = ' '.join(args.title)
    bug.set_title(title)
    bug.record_action('retitle ' + title)

def do_found(args):
    bug = lightbts.get_bug(args.id)
    bug.found(args.version)
    bug.record_action('found ' + args.version)

def do_notfound(args):
    bug = lightbts.get_bug(args.id)
    bug.notfound(args.version)
    bug.record_action('notfound ' + args.version)

def do_fixed(args):
    bug = lightbts.get_bug(args.id)
    bug.fixed(args.version)
    bug.record_action('fixed ' + args.version)

def do_notfixed(args):
    bug = lightbts.get_bug(args.id)
    bug.notfixed(args.version)
    bug.record_action('notfixed ' + args.version)

def do_severity(args):
    bug = lightbts.get_bug(args.id)
    bug.set_severity(args.severity)
    bug.record_action('severity ' + args.severity)

def do_merge(args):
    a = min(args.id)
    lightbts.merge(args.id)
    a.record_action('merge ' + ' '.join(args.id))

def do_unmerge(args):
    a = min(args.id)
    lightbts.unmerge(args.id)
    a.record_action('unmerge ' + ' '.join(args.id))

def do_tags(args):
    bug = lightbts.get_bug(args.id)
    add = True
    for tag in args.tags:
        if tag[0] == '-':
            add = False
            tag = tag[1:]
        elif tag[0] == '+':
            add = True
            tag = tag[1:]
        elif tag[0] == '=':
            add = True
            bug.clear_tags()
            tag = tag[1:]
        if tag:
            if add:
                bug.add_tag(tag)
            else:
                bug.del_tag(tag)
    bug.record_action('tags ' + ' '.join(args.tags))

def do_owner(args):
    bug = lightbts.get_bug(args.id)
    bug.set_owner(args.owner)
    bug.record_action('owner ' + args.owner)

def do_noowner(args):
    bug = lightbts.get_bug(args.id)
    bug.set_owner(None)
    bug.record_action('noowner')

def do_spam(args):
    lightbts.db.execute('UPDATE messages SET spam=1 WHERE msgid=?', (args.msgid,))

def do_nospam(args):
    lightbts.db.execute('UPDATE messages SET spam=0 WHERE msgid=?', (args.msgid,))

def do_deadline(args):
    timestamp = dateutil.parse(args.deadline)
    bug = lightbts.get_bug(args.id)
    bug.set_deadline(timestamp)
    bug.record_action('deadline ' + str(timestamp))

def do_milestone(args):
    bug = lightbts.get_bug(args.id)
    bug.set_milestone(args.milestone)
    bug.record_action('milestone ' + args.milestone)

def do_progress(args):
    try:
        value = int(args.progress.rstrip('%'))
    except ValueError:
        eprint("Invalid format for progress")
        exit(1)

    if value < 0 or value > 100:
        eprint("Progress value must be between 0 and 100")
        exit(1)

    bug = lightbts.get_bug(args.id)
    bug.set_progress(value)
    bug.record_action('progress ' + str(value))

# Initialize

if not os.getenv("TRACEBACK"):
    sys.tracebacklimit = 0

parser = argparse.ArgumentParser(description='Manage bugs.', epilog='Report bugs to guus@sliepen.org.')
parser.add_argument('-d', '--data', metavar='DIR', help='directory where LightBTS stores its data')
parser.add_argument('--version', action='version', version='LightBTS ' + lightbts.__version__)

subparser = parser.add_subparsers(title='commands', dest='command')

parser_init = subparser.add_parser('init', help='initialize bug database')
parser_init.add_argument('dir', help='directory to store bug database in', nargs='?')
parser_init.set_defaults(func=do_init)

parser_config = subparser.add_parser('config', help='get/set configuration option')
parser_config.add_argument('option', help='name of the option')
parser_config.add_argument('value', help='new value for the option', nargs='?')
parser_config.set_defaults(func=do_config)

parser_list = subparser.add_parser('list', help='list bugs')
parser_list.add_argument('prop', help='bug property (status, severity, tag)', nargs='*')
parser_list.set_defaults(func=do_list)

parser_show = subparser.add_parser('show', help='show bug or message details')
parser_show.add_argument('-v', '--verbose', help='show full text of all messages associated to the bug', action='store_true')
parser_show.add_argument('id', help='bug or message id')
parser_show.set_defaults(func=do_show)

parser_search = subparser.add_parser('search', help='search bugs')
parser_search.add_argument('term', help='search term', nargs=argparse.REMAINDER)
parser_search.set_defaults(func=do_search)

parser_create = subparser.add_parser('create', help='create a new bug')
parser_create.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found in the given version')
parser_create.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_create.add_argument('-S', '--severity', metavar='SEVERITY', help='set the bug severity')
parser_create.add_argument('title', help='bug title', nargs=argparse.REMAINDER)
parser_create.set_defaults(func=do_create)

parser_reply = subparser.add_parser('reply', help='reply to an existing bug')
parser_reply.add_argument('-c', '--close', help='close the bug', action='store_true')
parser_reply.add_argument('-r', '--reopen', help='reopen the bug', action='store_true')
parser_reply.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found (fixed if the -c flag is used) in the given version')
parser_reply.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_reply.add_argument('id', help='bug or message id')
parser_reply.set_defaults(func=do_reply)

parser_close = subparser.add_parser('close', help='close an existing bug')
parser_close.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as fixed in the given version')
parser_close.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_close.add_argument('id', help='bug id')
parser_close.set_defaults(func=do_close)

parser_reopen = subparser.add_parser('reopen', help='reopen an existing bug')
parser_reopen.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found in the given version')
parser_reopen.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_reopen.add_argument('id', help='bug id')
parser_reopen.set_defaults(func=do_reopen)

parser_retitle = subparser.add_parser('retitle', help='change title of an existing bug')
parser_retitle.add_argument('id', help='bug id')
parser_retitle.add_argument('title', help='new title', nargs=argparse.REMAINDER)
parser_retitle.set_defaults(func=do_retitle)

parser_found = subparser.add_parser('found', help='record version where the bug appears')
parser_found.add_argument('id', help='bug id')
parser_found.add_argument('version', help='project version')
parser_found.set_defaults(func=do_found)

parser_notfound = subparser.add_parser('notfound', help='remove record of version where the bug appears')
parser_notfound.add_argument('id', help='bug id')
parser_notfound.add_argument('version', help='project version')
parser_notfound.set_defaults(func=do_notfound)

parser_fixed = subparser.add_parser('fixed', help='record version where the bug is fixed')
parser_fixed.add_argument('id', help='bug id')
parser_fixed.add_argument('version', help='project version')
parser_fixed.set_defaults(func=do_fixed)

parser_notfixed = subparser.add_parser('notfixed', help='remove record of version where the bug is fixed')
parser_notfixed.add_argument('id', help='bug id')
parser_notfixed.add_argument('version', help='project version')
parser_notfixed.set_defaults(func=do_notfixed)

parser_severity = subparser.add_parser('severity', help='change bug severity')
parser_severity.add_argument('id', help='bug id')
parser_severity.add_argument('severity', help='bug id', choices=lightbts.severities)
parser_severity.set_defaults(func=do_severity)

parser_merge = subparser.add_parser('merge', help='merge two or more bugs')
parser_merge.add_argument('id', help='bug ids', nargs='+')
parser_merge.set_defaults(func=do_merge)

parser_unmerge = subparser.add_parser('unmerge', help='unmerge previously merged bugs')
parser_unmerge.add_argument('id', help='bug ids', nargs='+')
parser_unmerge.set_defaults(func=do_unmerge)

parser_tags = subparser.add_parser('tags', help='add or remove tags')
parser_tags.add_argument('id', help='bug id')
parser_tags.add_argument('tags', help='tags, optionally prefixed with + or -', nargs=argparse.REMAINDER)
parser_tags.set_defaults(func=do_tags)

parser_owner = subparser.add_parser('owner', help='set the owner of a bug')
parser_owner.add_argument('id', help='bug id')
parser_owner.add_argument('email', help='owner email address')
parser_owner.set_defaults(func=do_owner)

parser_noowner = subparser.add_parser('noowner', help='remove record of the owner of a bug')
parser_noowner.add_argument('id', help='bug id')
parser_noowner.set_defaults(func=do_noowner)

parser_spam = subparser.add_parser('spam', help='mark a message as spam')
parser_spam.add_argument('id', help='bug id')
parser_spam.set_defaults(func=do_spam)

parser_nospam = subparser.add_parser('nospam', help='mark a message as not being spam')
parser_nospam.add_argument('id', help='bug id')
parser_nospam.set_defaults(func=do_nospam)

parser_progress = subparser.add_parser('progress', help='set level of progress made')
parser_progress.add_argument('id', help='bug id')
parser_progress.add_argument('progress', help='progress made in percent (integers only)')
parser_progress.set_defaults(func=do_progress)

parser_milestone = subparser.add_parser('milestone', help='associate bug with a project milestone')
parser_milestone.add_argument('id', help='bug id')
parser_milestone.add_argument('milestone', help='milestone name')
parser_milestone.set_defaults(func=do_milestone)

parser_deadline = subparser.add_parser('deadline', help='set deadline for a bug')
parser_deadline.add_argument('id', help='bug id')
parser_deadline.add_argument('deadline', help='deadline (many date/time formats accepted)')
parser_deadline.set_defaults(func=do_deadline)


def do_help(args):
    if args.command:
        if args.command in subparser.choices:
            subparser.choices[args.command].print_help()
        else:
            eprint("Unknown command " + args.command)
            parser.print_usage(file = sys.stderr)
            exit(1)
    else:
        parser.print_help()

parser_help = subparser.add_parser('help', add_help='show help message')
parser_help.add_argument('command', help='command to show specific help message for', nargs='?')
parser_help.set_defaults(func=do_help)

args = parser.parse_args()

if args.func != do_init:
    lightbts.init(args.data)

args.func(args)

lightbts.exit()
