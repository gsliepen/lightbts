#!/usr/bin/python3.6

from __future__ import print_function

import os
import argparse
import sys
import subprocess
import tempfile
import email.message
import dateutil.parser
import mailbox
import hashlib

import lightbts

def is_interactive():
    return os.isatty(0) and os.isatty(1)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def do_init(args):
    if not args.dir:
        args.dir = args.data

    if not args.dir:
        args.dir = os.path.join(os.getcwd(), ".lightbts")

    new = not os.access(os.path.join(args.dir, "config"), os.F_OK)

    lightbts.init(args.dir)

    if new:
        eprint("Initialized empty LightBTS instance in " + args.dir)
    else:
        eprint("Reinitialized existing LightBTS instance in " + args.dir)

def do_config(args):
    option = args.option.split('.')
    if len(option) != 2:
        eprint("Invalid option name")
        exit(1)

    (section, option) = option

    if not args.value:
        try:
            print(lightbts.config.get(section, option))
        except:
            exit(1)
    else:
        if not lightbts.config.has_section(section):
            lightbts.config.add_section(section)
        lightbts.config.set(section, option, args.value)

def do_list(args):
    do_tags = False
    do_milestones = False
    if len(args.prop):
        if args.prop[-1] == "tags":
            args.prop.pop()
            tags = set()
            do_tags = True
        elif args.prop[-1] == "milestones":
            args.prop.pop()
            milestones = set()
            do_milestones = True
        elif args.prop[-1] == "bugs":
            args.prop.pop()

    for bug in lightbts.list_bugs(args):
        if do_tags:
            tags |= set(bug.get_tags())
        elif do_milestones:
            milestones.add(bug.get_milestone())
        else:
            print("{:>6} {:6} {:9}  {:}".format(bug.id, bug.statusname, bug.severityname, bug.title))

    if do_tags:
        for tag in tags:
            print(tag)
    elif do_milestones:
        for milestone in milestones:
            if milestone:
                print(milestone)

def do_show_bug(bugno, verbose):
    bug = lightbts.get_bug(bugno)
    if not bug:
        eprint('Could not find bug #' + str(bugno))
        exit(1)

    found_versions = bug.get_found_versions()
    fixed_versions = bug.get_fixed_versions()
    print('Bug#' + str(bug.id) + ': ' + bug.title)
    print('Status: ' + bug.statusname)
    if bug.submitter:
        print('Submitter:  ' + bug.submitter)
    if bug.owner != bug.submitter:
        print('Owner: ' + bug.owner)
    if bug.status and bug.progress:
        print('Progress: ' + str(bug.progress) + '%')
    if found_versions:
        print('Found in: ' + ' '.join(found_versions))
    if fixed_versions:
        print('Fixed in: ' + ' '.join(fixed_versions))
    print('Severity: ' + bug.severityname)
    tags = bug.get_tags()
    if tags:
        print('Tags: ' + ' '.join(tags))
    if bug.deadline:
        print('Deadline: ' + email.utils.formatdate(float(bug.deadline)))
    if bug.milestone:
        print('Milestone: ' + bug.milestone)

    for linktype, bugs in bug.get_links().items():
        print(lightbts.verbose_linktypes[linktype].capitalize() + ': ' + ' '.join([str(i) for i in bugs]))

    for linktype, bugs in bug.get_reverse_links().items():
        print(lightbts.reverse_linktypes[linktype].capitalize() + ': ' + ' '.join([str(i) for i in bugs]))

    print('')
    more = False

    for msg in bug.get_messages():
        if(verbose):
            if more:
                print('')
            print('From: ' + msg.msg['From'])
            print('To: ' + msg.msg['To'])
            print('Subject: ' + msg.msg['Subject'])
            print('Date: ' + msg.msg['Date'])
            print('Message-ID: ' + msg.msg['Message-ID'])
            print('')
            print(msg.msg.get_payload().rstrip());
            more = True
        else:
            print(msg.msgid)

def do_show_message(msgid):
    msg = lightbts.get_message(msgid)
    if not msg:
        eprint('Could not find message with id ' + msgid)
        exit(1)

    bug = lightbts.get_bug(msg.bug)
    found_versions = bug.get_found_versions()
    fixed_versions = bug.get_fixed_versions()
    print('Bug#' + str(bug.id) + ': ' + bug.title)
    print('Status: ' + bug.statusname)
    if found_versions:
        print('Found in: ' + ' '.join(found_versions))
    if fixed_versions:
        print('Fixed in: ' + ' '.join(fixed_versions))
    print('Severity: ' + bug.severityname)
    tags = bug.get_tags()
    if tags:
        print('Tags: ' + tags)
    print('')
    print(msg.msg.as_string().rstrip());

def do_show(args):
    if '@' in args.id:
        return do_show_message(args.id)
    else:
        return do_show_bug(int(args.id), args.verbose)

def do_search(args):
    for bug in lightbts.search_bugs(args):
        print("{:>6} {:6} {:9}  {:}".format(bug.id, bug.statusname, bug.severityname, bug.title))

def edit_interactive(msg, hint = 'bug'):
    # Find out which editor to use
    editor = lightbts.config.get("cli", "editor")
    if not editor:
        editor = os.getenv("VISUAL")
    if not editor:
        editor = os.getenv("EDITOR")
    if not editor:
        editor = "edit"

    # Create a temporary file, use .eml suffix (vim can use it for syntax highlighting)
    (fd, path) = tempfile.mkstemp(prefix="lightbts-" + hint + "-", suffix='.eml', text=True)
    file = os.fdopen(fd, "w+")

    #Write message
    text = msg.as_string()
    file.write(text)
    file.write('\n')

    file.seek(0)
    stat_before = os.fstat(fd)

    start = ''

    # Call the editor
    retval = subprocess.call([editor, '+' + str(start), path])

    if retval != 0:
        eprint('"' + editor + '" returned with a non-zero exit code')
        file.close()
        os.unlink(path)
        return None

    # Read back the edited message, if it was changed at all
    stat_after = os.fstat(fd)
    if stat_before.st_mtime == stat_after.st_mtime and stat_before.st_size == stat_after.st_size:
        result = None
    else:
        result = email.message_from_file(file);

    file.close()
    os.unlink(path)

    return result

def do_create(args):
    # Create message headers, start with From: so the file command recognizes it as message/rfc822
    msg = email.message.Message()
    msg['From'] = lightbts.get_local_email_address()
    msg['Subject'] = ' '.join(args.title)

    action = ''
    if args.version:
        action += 'Version: ' + args.version + '\n'
    if args.severity:
        action += 'Severity: ' + args.severity + '\n'
    if args.tag:
        action += 'Tags: +' + args.tag + '\n'
    if action:
        action += '\n'

    if is_interactive():
        msg.set_payload(action)
        msg = edit_interactive(msg, 'create')
        if not msg:
            eprint("Aborting new bug report.")
            exit(1)
    else:
        msg.set_payload(action + sys.stdin.read())

    msg['To'] = 'LightBTS'
    msg['Date'] = email.utils.formatdate()
    msg['User-Agent'] = 'LightBTS/' + lightbts.__version__

    (bug, new) = lightbts.import_email(msg)

    if not bug:
        exit(1)

    eprint('Thank you for reporting a bug, which has been assigned number ' + str(bug.id))

def quote(text):
    return ''.join('> ' + line + '\n' for line in text.strip('\n').split('\n'))

def do_reply(args):
    if args.close and args.reopen:
        eprint('Make up your mind!')
        exit(1)

    if '@' in args.id:
        origmsg = lightbts.get_message(args.id)
        if not origmsg:
            eprint('Could not find message ID ' + args.id)
            exit(1)
        bug = lightbts.get_bug(origmsg.get_bug())
    else:
        bug = lightbts.get_bug(int(args.id))
        if not bug:
            eprint('Could not find bug #' + args.id)
            exit(1)
        origmsg = lightbts.get_message(bug.get_first_msgid())

    # Create message headers, start with From: so the file command recognizes it as message/rfc822
    msg = email.message.Message()
    msg['From'] = lightbts.get_local_email_address()
    msg['Subject'] = bug.title

    action = ''
    if args.version:
        if args.close:
            action += 'Fixed: ' + args.version + '\n'
        else:
            action += 'Found: ' + args.version + '\n'
    if args.tag:
        action += 'Tags: +' + args.tag + '\n'
    if args.close:
        action += 'Status: closed\n'
    if args.reopen:
        action += 'Status: open\n'

    action += '\n'

    if is_interactive():
        origdate = origmsg.get_msg()['Date']
        (origrealname, origaddress) = email.utils.parseaddr(origmsg.get_msg()['From'])
        body = action + "On " + origdate + ", " + origrealname + " wrote:\n\n"
        body += quote(origmsg.get_body())

        msg.set_payload(body)

        msg = edit_interactive(msg, 'reply-' + str(bug.get_id()))
        if not msg:
            eprint("Aborting bug reply.")
            exit(1)
    else:
        msg.set_payload(action + sys.stdin.read())

    msg['To'] = 'LightBTS'
    msg['Date'] = email.utils.formatdate()
    msg['User-Agent'] = 'LightBTS/' + lightbts.__version__
    msg['In-Reply-To'] = '<' + origmsg.get_msgid() + '>'

    (bug, new) = lightbts.import_email(msg);

    eprint('Thank you for reporting additional information for bug number ' + str(bug.id))

def do_action(bug, action):
    # Create message headers, start with From: so the file command recognizes it as message/rfc822
    msg = email.message.Message()
    msg['From'] = lightbts.get_local_email_address()
    msg['Subject'] = bug.title

    if is_interactive():
        msg.set_payload(action)

        msg = edit_interactive(msg, 'reply-' + str(bug.get_id()))
        if not msg:
            eprint("Aborting bug action.")
            exit(1)
    else:
        msg.set_payload(action)

    msg['To'] = 'LightBTS'
    msg['Date'] = email.utils.formatdate()
    msg['User-Agent'] = 'LightBTS/' + lightbts.__version__
    msg['In-Reply-To'] = '<' + bug.get_first_msgid() + '>'

    (bug, new) = lightbts.import_email(msg);

    eprint('Action recorded for bug number ' + str(bug.id))


def do_close(args):
    bug = lightbts.get_bug(args.id)
    action = 'Status: closed\n'

    if args.version:
        action += 'Fixed: ' + args.version + '\n'

    if args.tag:
        action += 'Tags: +' + args.tag + '\n'

    do_action(bug, action)

def do_reopen(args):
    bug = lightbts.get_bug(args.id)
    action = 'Status: open\n'

    if args.version:
        action += 'Found: ' + args.version + '\n'

    if args.tag:
        action += 'Tags: +' + args.tag + '\n'

    do_action(bug, action)

def do_retitle(args):
    bug = lightbts.get_bug(args.id)
    title = ' '.join(args.title)
    do_action(bug, 'Title: ' + title);

def do_found(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Found: ' + args.version)

def do_notfound(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Notfound: ' + args.version)

def do_fixed(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Fixed: ' + args.version)

def do_notfixed(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Notfixed: ' + args.version)

def do_severity(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Severity: ' + args.severity)

def do_link(args):
    bug1 = lightbts.get_bug(args.id1)
    bug2 = lightbts.get_bug(args.id2)
    linktype = lightbts.linktypes[lightbts.linktypeindex(args.type)]
    do_action(bug1, linktype.capitalize() + ': ' + str(bug2.get_id()));

def do_unlink(args):
    bug1 = lightbts.get_bug(args.id1)
    bug2 = lightbts.get_bug(args.id2)
    linktype = lightbts.linktypes[lightbts.linktypeindex(args.type)]
    do_action(bug1, 'Un' + linktype + ': ' + str(bug2.get_id()));

def do_tags(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Tags: ' + ' '.join(args.tags))

def do_owner(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Owner: ' + args.email)

def do_noowner(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Owner: -')

def do_spam(args):
    lightbts.db.execute('UPDATE messages SET spam=1 WHERE msgid=?', (args.msgid,))

def do_nospam(args):
    lightbts.db.execute('UPDATE messages SET spam=0 WHERE msgid=?', (args.msgid,))

def do_deadline(args):
    timestamp = dateutil.parser.parse(args.deadline)
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Deadline: ' + args.deadline)

def do_milestone(args):
    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Milestone: ' + args.milestone)

def do_progress(args):
    try:
        value = int(args.progress.rstrip('%'))
    except ValueError:
        eprint("Invalid format for progress")
        exit(1)

    if value < 0 or value > 100:
        eprint("Progress value must be between 0 and 100")
        exit(1)

    bug = lightbts.get_bug(args.id)
    do_action(bug, 'Progress: ' + args.progress)

def do_index(args):
    lightbts.update_index(args.filename)

def do_fsck(args):
    warnings = 0
    errors = 0

    # Check if all messages in the index appear in the messages directory
    filenames = set()
    for i in lightbts.db.execute('SELECT msgid, bug FROM messages'):
        if not i[1]:
            # MsgID was added but never assigned to a bug, due to errors during processing.
            # TODO: remove these?
            eprint('Warning: bug 0 msgid ' + msgid)
            warnings += 1
        hash = hashlib.blake2b(i[0].encode(), digest_size=24).hexdigest()
        filename = os.path.join(lightbts.maildir, hash[0:2], hash[2:])
        print(filename)
        filenames.add(filename)

        msg = email.message_from_file(open(filename, "r"))
        if msg['Message-ID'][1:-1] != i[0]:
            # Message-ID in file and in index don't match.
            # TODO: update the index?
            eprint('Error: mismatching Message-ID: ' + msg['Message-ID'] + ' != ' + i[0])
            errors += 1

    # Check if there are any files in the messages directory that do not appear in the index
    for root, dirs, filenames in os.walk(lightbts.maildir):
        for filename in filenames:
            if os.path.join(root, filename) not in filenames:
                # A file was found that doesn't appear in the index.
                # TODO: delete or update index, depending on whether it's in <bugno>/cur/ or in another directory
                eprint('Error: unindexed file ' + os.path.join(root, filename))
                errors += 1

    if errors:
        eprint("Errors were found.")
        exit(1)

    if warnings:
        eprint("Warnings were found.")

# Initialize

if not os.getenv("TRACEBACK"):
    sys.tracebacklimit = 0

parser = argparse.ArgumentParser(description='Manage bugs.', epilog='Report bugs to guus@sliepen.org.')
parser.add_argument('-d', '--data', metavar='DIR', help='directory where LightBTS stores its data')
parser.add_argument('--version', action='version', version='LightBTS ' + lightbts.__version__)
parser.add_argument('--batch', action='store_true', help='no interactive input')
parser.add_argument('--no-email', action='store_true', help='do not send email messages')
parser.add_argument('--no-hooks', action='store_true', help='do not call hooks')

subparser = parser.add_subparsers(title='commands', dest='command')

parser_init = subparser.add_parser('init', help='initialize bug database')
parser_init.add_argument('dir', help='directory to store bug database in', nargs='?')
parser_init.set_defaults(func=do_init)

parser_config = subparser.add_parser('config', help='get/set configuration option')
parser_config.add_argument('option', help='name of the option')
parser_config.add_argument('value', help='new value for the option', nargs='?')
parser_config.set_defaults(func=do_config)

parser_list = subparser.add_parser('list', help='list bugs')
parser_list.add_argument('prop', help='bug property (status, severity, tag)', nargs='*')
parser_list.set_defaults(func=do_list)

parser_show = subparser.add_parser('show', help='show bug or message details')
parser_show.add_argument('-v', '--verbose', help='show full text of all messages associated to the bug', action='store_true')
parser_show.add_argument('id', help='bug or message id')
parser_show.set_defaults(func=do_show)

parser_search = subparser.add_parser('search', help='search bugs')
parser_search.add_argument('term', help='search term', nargs=argparse.REMAINDER)
parser_search.set_defaults(func=do_search)

parser_create = subparser.add_parser('create', help='create a new bug')
parser_create.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found in the given version')
parser_create.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_create.add_argument('-S', '--severity', metavar='SEVERITY', help='set the bug severity')
parser_create.add_argument('title', help='bug title', nargs=argparse.REMAINDER)
parser_create.set_defaults(func=do_create)

parser_reply = subparser.add_parser('reply', help='reply to an existing bug')
parser_reply.add_argument('-c', '--close', help='close the bug', action='store_true')
parser_reply.add_argument('-r', '--reopen', help='reopen the bug', action='store_true')
parser_reply.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found (fixed if the -c flag is used) in the given version')
parser_reply.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_reply.add_argument('id', help='bug or message id')
parser_reply.set_defaults(func=do_reply)

parser_close = subparser.add_parser('close', help='close an existing bug')
parser_close.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as fixed in the given version')
parser_close.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_close.add_argument('id', help='bug id')
parser_close.set_defaults(func=do_close)

parser_reopen = subparser.add_parser('reopen', help='reopen an existing bug')
parser_reopen.add_argument('-V', '--version', metavar='VERSION', help='mark the bug as found in the given version')
parser_reopen.add_argument('-T', '--tag', metavar='TAG', help='set the given tag')
parser_reopen.add_argument('id', help='bug id')
parser_reopen.set_defaults(func=do_reopen)

parser_retitle = subparser.add_parser('retitle', help='change title of an existing bug')
parser_retitle.add_argument('id', help='bug id')
parser_retitle.add_argument('title', help='new title', nargs=argparse.REMAINDER)
parser_retitle.set_defaults(func=do_retitle)

parser_found = subparser.add_parser('found', help='record version where the bug appears')
parser_found.add_argument('id', help='bug id')
parser_found.add_argument('version', help='project version')
parser_found.set_defaults(func=do_found)

parser_notfound = subparser.add_parser('notfound', help='remove record of version where the bug appears')
parser_notfound.add_argument('id', help='bug id')
parser_notfound.add_argument('version', help='project version')
parser_notfound.set_defaults(func=do_notfound)

parser_fixed = subparser.add_parser('fixed', help='record version where the bug is fixed')
parser_fixed.add_argument('id', help='bug id')
parser_fixed.add_argument('version', help='project version')
parser_fixed.set_defaults(func=do_fixed)

parser_notfixed = subparser.add_parser('notfixed', help='remove record of version where the bug is fixed')
parser_notfixed.add_argument('id', help='bug id')
parser_notfixed.add_argument('version', help='project version')
parser_notfixed.set_defaults(func=do_notfixed)

parser_severity = subparser.add_parser('severity', help='change bug severity')
parser_severity.add_argument('id', help='bug id')
parser_severity.add_argument('severity', help='bug id', choices=lightbts.severities)
parser_severity.set_defaults(func=do_severity)

parser_merge = subparser.add_parser('link', help='add a link between two bugs')
parser_merge.add_argument('id1', help='bug id')
parser_merge.add_argument('type', help='link type (relates, duplicates, depends, blocks)')
parser_merge.add_argument('id2', help='bug id')
parser_merge.set_defaults(func=do_link)

parser_merge = subparser.add_parser('unlink', help='remove a link between two bugs')
parser_merge.add_argument('id1', help='bug id')
parser_merge.add_argument('type', help='link type (relates, duplicates, blocks, depends)')
parser_merge.add_argument('id2', help='bug id')
parser_merge.set_defaults(func=do_unlink)

parser_tags = subparser.add_parser('tags', help='add or remove tags')
parser_tags.add_argument('id', help='bug id')
parser_tags.add_argument('tags', help='tags, optionally prefixed with + or -', nargs=argparse.REMAINDER)
parser_tags.set_defaults(func=do_tags)

parser_owner = subparser.add_parser('owner', help='set the owner of a bug')
parser_owner.add_argument('id', help='bug id')
parser_owner.add_argument('email', help='owner email address')
parser_owner.set_defaults(func=do_owner)

parser_noowner = subparser.add_parser('noowner', help='remove record of the owner of a bug')
parser_noowner.add_argument('id', help='bug id')
parser_noowner.set_defaults(func=do_noowner)

parser_spam = subparser.add_parser('spam', help='mark a message as spam')
parser_spam.add_argument('id', help='bug id')
parser_spam.set_defaults(func=do_spam)

parser_nospam = subparser.add_parser('nospam', help='mark a message as not being spam')
parser_nospam.add_argument('id', help='bug id')
parser_nospam.set_defaults(func=do_nospam)

parser_progress = subparser.add_parser('progress', help='set level of progress made')
parser_progress.add_argument('id', help='bug id')
parser_progress.add_argument('progress', help='progress made in percent (integers only)')
parser_progress.set_defaults(func=do_progress)

parser_milestone = subparser.add_parser('milestone', help='associate bug with a project milestone')
parser_milestone.add_argument('id', help='bug id')
parser_milestone.add_argument('milestone', help='milestone name')
parser_milestone.set_defaults(func=do_milestone)

parser_deadline = subparser.add_parser('deadline', help='set deadline for a bug')
parser_deadline.add_argument('id', help='bug id')
parser_deadline.add_argument('deadline', help='deadline (many date/time formats accepted)')
parser_deadline.set_defaults(func=do_deadline)

parser_deadline = subparser.add_parser('index', help='update index for a given message file')
parser_deadline.add_argument('filename', help='file to index')
parser_deadline.set_defaults(func=do_index)

parser_deadline = subparser.add_parser('fsck', help='perform an integrity check')
parser_deadline.set_defaults(func=do_fsck)

def do_help(args):
    if args.command:
        if args.command in subparser.choices:
            subparser.choices[args.command].print_help()
        else:
            eprint("Unknown command " + args.command)
            parser.print_usage(file = sys.stderr)
            exit(1)
    else:
        parser.print_help()

parser_help = subparser.add_parser('help', add_help='show help message')
parser_help.add_argument('command', help='command to show specific help message for', nargs='?')
parser_help.set_defaults(func=do_help)

args = parser.parse_args()

if args.no_email:
    lightbts.quiet = True

if args.no_hooks:
    lightbts.no_hooks = True

if args.func != do_init and args.func != do_help:
    lightbts.init(args.data)

args.func(args)

if args.func != do_help:
    lightbts.exit()
